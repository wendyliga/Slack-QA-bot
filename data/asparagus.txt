Asparagus

Named "Asparagus" because it beautifully reflects the way we track our app size changes. Just like how asparagus consists of shoots growing on top of shoots, we monitor our app size by building upon the previous app size.

Introduction

Asparagus is a system employed to monitor app size changes for every commit to develop branch. Using Jenkins and Google Sheets, Asparagus will build a TestFlight build, upload and fetch the binary size from AppStore Connect and save it to Google Sheets. Data stored on Google Sheets will be represented as a dashboard using Google looker studio.

Motivation

Monitoring and safeguarding the app size for iOS apps is of paramount importance for several reasons, particularly when considering apps like Tokopedia that update weekly. The frequent updates of the Tokopedia iOS app could potentially frustrate users if the app's size is not kept in check. When an app grows larger with each update, it burdens users' device storage significantly, resulting in diminished available space for other essential content. This can lead to user dissatisfaction and even app deletions, causing a loss of potential customers and revenue for the company.

Additionally, larger app sizes translate to longer download and update times, which can be particularly challenging for users with slower internet connections. Users may abandon the update process midway, unable to afford the time and data necessary for these frequent large updates. The constant need to update the app weekly may become an inconvenience and a deterrent for users to stay up-to-date with the latest features and bug fixes, leaving them vulnerable to security risks and missing out on improvements in the app's functionality.

Furthermore, considering Apple's App Store guidelines, which impose limitations on app sizes for cellular downloads. If an app exceeds 200MB in size, users attempting to download or update the app using cellular data will receive a warning message. This limitation is in place to protect users from unexpected data usage, as larger apps can quickly consume a significant portion of their data plans.

Monitoring app size changes for each commit plays a crucial role in both tracking the evolution of the app's size and understanding the nature of improvements merged into the develop branch. By closely monitoring size changes, developers can pinpoint specific code changes or asset additions that contribute to size increments. This enables them to proactively identify potential sources of bloat and address them before they become significant issues. Additionally, analyzing size changes in correlation with commits allows developers to gain valuable insights into the impact of each code change on the app's overall size. This knowledge is invaluable in making informed decisions about future development, optimizing performance, and maintaining a streamlined and efficient app. Ultimately, by regularly monitoring app size changes, development teams can foster a culture of continuous improvement, ensuring that the app remains lean, responsive, and user-friendly throughout its lifecycle.

Proposed Solution

Some sort of system is needed to be able to run automatically and autonomously each time an improvement is merged to develop a branch.

TokoAsparagus

A Pipeline will monitor each change in develop branch, every change in develop then will trigger another pipeline that will run the AppStore build and upload it to a custom app called TokoAsparagus(This custom app is there so we don’t clutter the build on production app and release candidate). After a successful upload to AppStore, we will use AppStoreConnect API  to fetch a particular build and then store the app size to Google Sheets.

Trigger Pipeline

Asparagus Trigger pipeline on Jenkins

We will use Multibranch Pipeline on Jenkins to achieve this. Multibranch Pipeline is a little bit different compared to the default pipeline, as we can deploy different configurations for a particular branch, and in this case, we can monitor develop branch only, and ignore another branch.

Asparagus (trigger) will monitor any changes to develop branch. if any is detected, then will trigger the Asparagus pipeline.

Asparagus pipeline

Asparagus pipeline on Jenkins

Asparagus pipeline will be responsible for the rest of the process, including building the app store build, uploading, fetching the app size, and storing it in Google Sheets. This pipeline will become the Conductor, that will call the appropriate tools to finish the job.

Asparagus pipeline parameter

Asparagus trigger will pass BRANCH_NAME and COMMIT_HASH to the Asparagus pipeline to start the job. We want COMMIT_HASH here as it is possible to run concurrent build, if for example on Monday several commits are merged near each other.

Asparagus pipeline is using throttle build, it will only build 15 times a day, approx once per 96 minutes. This is to counter the issue of exceeding the upload quota, as Apple implemented.

After the Asparagus pipeline is triggered, this is the step-by-step how it works.

The pipeline will checkout to the specific branch and commit hash. Upon the checkout stage, this pipeline will fetch information like commit hash, commit date, commit message, and email.

Next, we will check if the existing commit hash is already tracked on the database. We will call tools/google_sheet/read_asparagus.py which will fetch all data from the Asparagus Google sheet. After fetching we will check based on JSON fetch from read_asparagus.py. The data will also be stored locally on the file called fastlane/ASPARAGUS so it can be used again in a later stage.

In this step, We will do several housekeeping tasks to configure an environment to build the AppStore app, setting up the bundler, keychain, and provisioning profile.

After that, we will call ruby tools/tkpd-versioning.rb setAsparagusVersion which will change the version of the app to 0.0.1.

Afterwards, we will build the AppStore app, but to differentiate it from the AppStore production version we will pass tokoasparagus:true on bundle exec fastlane appstore_bazel. this config will translate to different provisioning and certificate when signing, and use_remote_cache:true to enable caching build. we don’t enable this by default and on AppStore production to reduce the possibility of weird bugs, but we want to enable this on Asparagus to improve build speed.

Then we will upload the build to AppStore. we will reuse the TestFlight upload function like AppStore production, but with tokoasparagus:true. this config is set to set this function to upload to TokoAsparagus app_id. bundle exec fastlane upload_testflight will upload to AppStore, and wait until the processing phase finish on AppStore, it usually takes 5-20 minutes to finish the process.

We will then fetch the app size from AppStoreConnect using AppStoreConnect API. We will piggyback the existing infrastructure for the Symboligator backend, and modify it a little bit to fetch the TestFlight app size instead of the production app size. We will call bundle exec fastlane get_asparagus_size to curl to Symboligator backend endpoint  http://172.31.12.136:1040/getTokoAsparagusTestflightSize and pass a respective parameter to fetch app size data. To pass the data back to Jenkins, this function will write the data to files like fastlane/download_size, fastlane/install_size, and fastlane/raw_json. In the end, we also add an after_all, a constructor on Fastlane that will run on each finished function. we will send a Slack message to the committed owner regarding the app size.

Last but not least, we will save data like version, branch name, commit date, commit hash, commit message, commit email, download size, install size, and raw JSON of AppStoreConnect API response to Google sheet using tools/google_sheet/Asparagus.py and store it to Google Sheet.

Google Sheet data 

Calculating Size Impact per Commit

The way Asparagus calculate the size difference is by calculating the different download size and install size per commit sorted periodically. This way, each increase or decrease can be detected, but this means we need to make sure that no build is missing, or the data can be unreliable.

We create another Sheet here, that will use all data from Asparagus Sheet but sorted it based on the commit date. Then we will apply a simple formula to subtract the current size from the previous size.

Asparagus Sorted

Notification to Developer

slack message example

To enable developers to monitor the impact of their improvement, each time Asparagus is finished, it will send a Slack message to the respective developer regarding their recent improvement to develop and how it impacts the size.

Asparagus will read the commit email to determine which slack user it is, based on .github/github-slack-users.json.That being said, we need to maintain an email map to the Slack user id. As several developers enable private email on GitHub, we also need to map their private email.

Github Settings → Emails → Keep my email addresses private

Notification Channel [ON PROGRESS]

We will create a private channel on Slack as an enabler for monitoring size impact called ios-asparagus.

This channel will display all asparagus results (outside asparagus results to the respective developer) and will alert all iOS leads if any particular changes result in an increase bigger than 500kb.

Dashboard

Asparagus Dashboard

All data saved on Google Sheets then will be presented as Dashboard. This dashboard will show charts like size progress, daily size changes, per version size changes, and many more.

Google Sheets

Using Google Sheets as a data storage solution offers several compelling advantages for the current case. Firstly, it is cost-effective, as Google Sheets is a free service, making it ideal for projects with budget constraints. Additionally, its cloud-based nature enables easy accessibility and real-time collaboration among team members, promoting seamless data management. The user-friendly interface requires no specialized technical knowledge, allowing anyone to manage data effortlessly. Moreover, Google Sheets integrates smoothly with other Google tools, such as Google Dashboard, enabling the creation of visually appealing data visualizations. While Google Sheets may not handle massive datasets, it proves scalable for small to medium-sized projects like Asparagus. Furthermore if we want to migrate to another database solution, data from Google Sheet can be converted to csv, which should work with most of database solution.

Important Links

trigger pipeline: https://tools.tokopedia.net/jenkins-ios/job/Asparagus (trigger)/

asparagus pipeline: https://tools.tokopedia.net/jenkins-ios/job/Asparagus/

raw google sheet:  

sorted google sheet:  

dashboard: https://lookerstudio.google.com/u/0/reporting/1pglLEXb2JVnIkO2pcs9kELr2knX7JbcF/page/p_lngiuz076c